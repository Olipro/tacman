<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html 
     PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
  <head>
    <title>File: README</title>
    <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
    <link rel="stylesheet" href=".././rdoc-style.css" type="text/css" media="screen" />

    <script language="JavaScript" type="text/javascript">
    // <![CDATA[

        function toggleSource( id )
        {
          var elem
          var link

          if( document.getElementById )
          {
            elem = document.getElementById( id )
            link = document.getElementById( "l_" + id )
          }
          else if ( document.all )
          {
            elem = eval( "document.all." + id )
            link = eval( "document.all.l_" + id )
          }
          else
            return false;

          if( elem.style.display == "block" )
          {
            elem.style.display = "none"
            link.innerHTML = "show source"
          }
          else
          {
            elem.style.display = "block"
            link.innerHTML = "hide source"
          }
        }

        function openCode( url )
        {
          window.open( url, "SOURCE_CODE", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=480,width=750" ).focus();
        }
      // ]]>
    </script>
  </head>

  <body>
  <table border='0' cellpadding='0' cellspacing='0' width="100%" class='banner'>
  <tr><td>
    <table width="100%" border='0' cellpadding='0' cellspacing='0'><tr>
      <td class="file-title" colspan="2"><span class="file-title-prefix">File</span><br />README</td>
      <td align="right">
        <table border='0' cellspacing="0" cellpadding="2">
          <tr>
            <td>Path:</td>
            <td>README
            </td>
          </tr>
          <tr>
            <td>Modified:</td>
            <td>Sun Dec 16 17:45:38 +0530 2007</td>
          </tr>
        </table>
      </td></tr>
    </table>
  </td></tr>
</table><br />
 <!-- banner header -->

  <div id="bodyContent">
      <div id="content">

  <div class="description"><h1><a href="../classes/BackgrounDRb.html">BackgrounDRb</a></h1>
<p>
<a href="../classes/BackgrounDRb.html">BackgrounDRb</a> is a Ruby job
server and scheduler. Its main intent is to be used with Ruby on Rails
applications for offloading long-running tasks. Since a Rails application
blocks while serving a request it is best to move long-running tasks off
into a background process that is divorced from http request/response
cycle.
</p>
<p>
This new release of <a href="../classes/BackgrounDRb.html">BackgrounDRb</a>
is also modular and can be used without Rails so that any Ruby program or
framework can use it.
</p>
<p>
Copyright (c) 2006 Ezra Zygmuntowicz,skaar[at]waste[dot]org,
</p>
<p>
Copyright (c) 2007 Hemant Kumar (mail[at]gnufied[dot]org)
</p>
<h2>Usage</h2>
<h3>Installation</h3>
<p>
Getting the code:
</p>
<pre>
  svn co http://svn.devjavu.com/backgroundrb/trunk
</pre>
<p>
Installation with svn externals:
</p>
<pre>
  svn propedit svn:externals vendor/plugins
  [add the following line:]
  backgroundrb http://svn.devjavu.com/backgroundrb/trunk
  [exit editor]

  svn ci -m 'updating svn:external svn property for backgroundrb' vendor/plugins
  svn up vendor/plugins
  rake backgroundrb:setup
</pre>
<p>
Installation with piston:
</p>
<pre>
  piston import http://svn.devjavu.com/backgroundrb/trunk/ backgroundrb
</pre>
<h3>Configuration</h3>
<p>
Use rake task for initial configuration:
</p>
<ul>
<li>Cron style scheduling and config

<pre>
 | :backgroundrb:
 |   :ip: 0.0.0.0
 |   :port: 11006
 |   :environment: production
 |
 | :schedules:
 |   :foo_worker:
 |     :foobar:
 |       :trigger_args: */5 * * * * * *
 |       :data: Hello World
 |     :barbar:
 |       :trigger_args: */10 * * * * * *
</pre>
</li>
</ul>
<p>
The above sample configuration file would schedule worker methods
&#8216;foobar&#8217; and &#8216;barbar&#8217; from within FooWorker to be
executed at different trigger periods. Also, it would load production rails
environment. If you skip the :environment option, development environment
will be loaded by default.
</p>
<p>
NOTE: Because of the addition of this feature the format of
backgroundrb.yml has changed slightly and you must modify your config file
according to this new option.
</p>
<ul>
<li>Normal Unix scheduler

<pre>
 | :backgroundrb:
 |   :ip: 0.0.0.0
 |   :port: 11006
 | :schedules:
 |   :foo_worker:
 |     :foobar:
 |       :trigger_args:
 |         :start: &lt;%= Time.now + 5.seconds %&gt;
 |         :end: &lt;%= Time.now + 10.minutes %&gt;
 |         :repeat_interval: &lt;%= 1.minute %&gt;
</pre>
</li>
<li>Plain config

<pre>
 | :backgroundrb:
 |   :ip: 0.0.0.0
 |   :port: 11006
</pre>
</li>
</ul>
<h3>Scheduling</h3>
<p>
There are three schemes for periodic execution and scheduling.
</p>
<ul>
<li>Cron Scheduling

<p>
You can use a configuration file for cron scheduling of workers. The method
specified in the configuration file would be called periodically. You
should accommodate for the fact that the time gap between periodic
invocation of a method should be more than the time that is actually
required to execute the method. If a method takes longer time than the time
window specified, your method invocations will lag perpetually.
</p>
</li>
<li>Normal Scheduler

<pre>
  You can use second form of scheduling as shown in config file.
</pre>
</li>
<li>add_periodic_timer method

<pre>
  A third and very basic form of scheduling that you can use is, &quot;add_periodic_timer&quot; method. You can call this
  method from anywhere in your worker.

         def create
           add_periodic_timer(5) { say_hello }
         end
</pre>
</li>
</ul>
<p>
The above snippet would register the proc for periodic execution at every 5
seconds.
</p>
<h3>A Word about Cron Scheduler</h3>
<pre>
  Note that the initial field in the BackgrounDRb cron trigger specifies
  seconds, not minutes as with Unix-cron.

  The fields (which can be an asterisk, meaning all valid patterns) are:

    sec[0,59] min[0,59], hour[0,23], day[1,31], month[1,12], weekday[0,6], year

  The syntax pretty much follows Unix-cron. The following will trigger
  on the first hour and the thirtieth minute every day:

    0 30 1 * * * *

  The following will trigger the specified method every 10 seconds:

     */10 * * * * * *

  The following will trigger the specified method every 1 hour:

     0 0 * * * * *

  For each field you can use a comma-separated list. The following would
  trigger on the 5th, 16th and 23rd minute every hour:

    0 5,16,23 * * * * *

  Fields also support ranges, using a dash between values. The following
  triggers from 8th through the 17th hour, at five past the hour:

    0 5 8-17 * * * *

  Finally, fields support repeat interval syntax. The following triggers
  every five minutes, every other hour after the sixth hour:

    0 */5 6/2 * * * *

  Here is a more complex example: months 0,2,4,5,6,8,10,12, every day
  and hour, minutes 1,2,3,4,6,20, seconds: every 5th second counting
  from the 28th second plus the 59th second:

    28/5,59 1-4,6,20 */1 * 5,0/2 * *

  Note that if you specify an asterisk in the first field (seconds)
  it will trigger every second for the subsequent match.
</pre>
<h3>Writing Workers</h3>
<ul>
<li>Generate a Worker

<p>
Install the plugin and run the setup task (rake backgroundrb:setup). Now
create a worker using worker generator.
</p>
<pre>
        ./script/generate worker bar
</pre>
<p>
This will create a bar_worker.rb in your RAILS_ROOT/lib/workers/ (called
WORKER_ROOT henceforth). The generated code will look like this:
</p>
<pre>
 class BarWorker &lt; BackgrounDRb::MetaWorker
   set_worker_name :bar_worker
   def create
     # this method is called, when worker is loaded for the first time
     puts &quot;starting a bar worker&quot;
   end
   # define other methods, that you will invoke from rails.
 end
</pre>
<p>
All the workers inside WORKER_ROOT directory will be automatically loaded
and forked into a separate process. If you don&#8216;t want to start one
particular worker automatically you can use following class method
(set_no_auto_load) to disable that behaviour:
</p>
<pre>
  class DynamicWorker &lt; BackgrounDRb::MetaWorker
    set_worker_name :dynamic_worker
    set_no_auto_load true
  end
</pre>
<p>
The &#8216;create&#8217; method gets called when a worker is loaded and
created. Each worker runs in its own process and you can use
&#8216;create&#8217; for initializing worker specific stuff.
</p>
<p>
The following code snippet would ask bdrb to execute method
&#8216;add_values&#8217; in &#8216;foo_worker&#8217; with arguments
&#8216;10+10&#8217; and return the result.
</p>
<pre>
     MiddleMan.send_request(:worker =&gt; :foo_worker, :worker_method =&gt; :add_values,:data =&gt; &quot;10+10&quot;)

 When you are using the 'send_request' method, you are expecting a result back.  As such, the above code
 will block until your worker invokes a send response. The worker code for handling the above

  method would look like

     class FooWorker &lt; BackgrounDRb::MetaWorker
       set_worker_name :foo_worker
       def create(args = nil)
         #register_status(&quot;Running&quot;)
       end

       def add_values(args = nil)
         evaluated_result = eval(args)
         return evaluated_result
       end
     end

  However, when you want one shot execution of a worker_method without worrying about the results, you
  can use:

       MiddleMan.ask_work(:worker =&gt; :foo_worker, :worker_method =&gt; :add_values, :data =&gt; &quot;10+10&quot;)

  You can also use register_status as described in the following snippet to register the status of
  your worker with master, which can be directly queried from rails.

       register_status(some_status_data)

  From rails, you can query status of your worker object using following code:

       MiddleMan.ask_status(:worker =&gt; :foo_worker)

  The above code would return status object of 'foo_worker'. When you call register_status
  from a worker, it replaces the older state of the worker with master. Since master process
  stores the status of the worker, all the status queries are served by master itself. It can be

  used to store result hashes and stuff.
</pre>
</li>
<li>Starting and stopping a worker from Rails :

<p>
All workers can be dynamically started and stopped from rails. You can also
use separate job_keys to run more than one copy of a worker at a time.
</p>
<p>
For example, the following code in a rails controller will start
&quot;error_worker&quot; and schedule it to run according to the arguments
associated with trigger_args.
</p>
<pre>
  MiddleMan.new_worker(:worker =&gt; :error_worker, :job_key =&gt; :hello_world,:data =&gt; &quot;wow_man&quot;,:schedule =&gt; { :hello_world =&gt; { :trigger_args =&gt; &quot;*/5 * * * * * *&quot;,:data =&gt; &quot;hello_world&quot; }})
</pre>
<p>
NOTE: The first data argument will be passed to the create method inside
your worker. However, one specified under the :schedule heading would be
used by the worker method when its schedule comes.
</p>
<p>
To stop a worker, you can use:
</p>
<pre>
  MiddleMan.delete_worker(:worker =&gt; :error_worker, :job_key =&gt; :hello_world)
</pre>
<p>
If no job_key is specified the general worker name itself becomes job_key.
You should create job_keys with care so they are never the same for one
worker class.
</p>
</li>
<li>Starting and stopping from CLI :

<p>
To start:
</p>
<pre>
    ./script/backgroundrb start
</pre>
<p>
To stop:
</p>
<pre>
    ./script/backgroundrb stop
</pre>
</li>
<li>Query Status/Result of a worker :

<p>
All Workers can log their results with master, using the
&#8216;register_status&#8217; method. This status can be queried from rails
using ask_status. For example:
</p>
<pre>
 class ProgressWorker &lt; BackgrounDRb::MetaWorker
   set_worker_name :progress_worker
   def create
     @counter = 0
     add_periodic_timer(2) { increment_counter }
   end
   def increment_counter
     @counter += 1
     register_status(@counter)
   end
 end
</pre>
<p>
And using MiddleMan proxy, you can keep querying the status of your
progress bar:
</p>
<pre>
   MiddleMan.ask_status(:worker =&gt; :progress_worker)
</pre>
</li>
<li>Query status of All workers :

<p>
You can also query the status of all currently running workers in one shot.
</p>
<pre>
  def ask_status
    t_response = MiddleMan.query_all_workers
    running_workers = t_response.map { |key,value| &quot;#{key} = #{value}&quot;}.join(',')
    render :text =&gt; running_workers
  end
</pre>
<p>
Currently, when a worker is deleted/exits, its result/status is also gone
(i.e. you can&#8216;t query the status of a worker which is not running).
This behaviour is expected to change in future releases.
</p>
</li>
<li>Important difference between MiddleMan.ask_work and MiddleMan.send_request
:

<p>
As noted previously ask_work is used when you want one shot execution of a
worker method without waiting for results in rails. So an explicit return
statement is not required. But when you use MiddleMan.send_request, you are
asking BDRB, &quot;ok please execute this method on worker and I will wait
for results until the method returns&quot;. Hence in this case, you must
return the value you want to get back in rails.
</p>
<p>
Not all objects can be dumped in ruby. If you are trying to send an object
which can&#8216;t be dumped, you will get error messages logged in your log
file and will get an error string in your controller, too.
</p>
<p>
For example, let&#8216;s say you are invoking method
&quot;hello_world&quot; from &#8216;foo_controller&#8217; like this:
</p>
<pre>
  worker_response = MiddleMan.send_request(:worker =&gt; :foo_worker, :worker_method =&gt; :hello_world)
</pre>
<p>
And &#8216;hello_world&#8217; method inside &#8216;foo_worker&#8217; looks
like this:
</p>
<pre>
  def hello_world
    a = lambda { &quot;Hello world&quot; }
    return a
  end
</pre>
<p>
Now since a lambda can&#8216;t be dumped, the worker_response that you will
receive in your controller will be,
&#8216;invalid_result_dump_check_log&#8217; and an appropriate error will
also be logged in the backgroundrb.log file. Now, such an error could
potentially abort the BDRB worker. Hence, make sure that you avoid such
cases.
</p>
</li>
<li>Running <a href="../classes/BackgrounDRb.html">BackgrounDRb</a> clusters
and storing of results in Memcache cluster

<p>
New version allows access to worker status objects even after a worker has
died/exited. By default, this data would be held in Master Process memory.
Those of you, who want to run, <a
href="../classes/BackgrounDRb.html">BackgrounDRb</a> in a cluster, and if
you run a <a href="../classes/BackgrounDRb.html">BackgrounDRb</a> server on
each node and would rather want results to be stored in MemCache, you can
use following option for storing results in MemCache:
</p>
<pre>
    # backgroundrb.yml

    | :backgroundrb:
    |   :port: 11006
    |   :ip: 0.0.0.0
    |   :log: foreground
    |   :result_storage:
    |     :memcache: &quot;10.10.10.2:11211,10.10.10.6:11211&quot;
</pre>
</li>
<li>Using Threads inside <a
href="../classes/BackgrounDRb.html">BackgrounDRb</a> :

<p>
Remember <a href="../classes/BackgrounDRb.html">BackgrounDRb</a> follows
event model of network programming, but sad truth of life is not all
networking libraries follow this model and hence they make use of blocking
IO and threads. <a href="../classes/BackgrounDRb.html">BackgrounDRb</a>
allows you to run all such tasks concurrently in threads which are
internally managed by <a
href="../classes/BackgrounDRb.html">BackgrounDRb</a> thread pool.
</p>
<p>
Each worker has access to object <tt>thread_pool</tt> which can be used to
run task in a thread concurrently.
</p>
<pre>
  thread_pool.defer(wiki_scrap_url) { |wiki_url| scrap_wikipedia(wiki_url) }
</pre>
<p>
So whatever task you specify within <tt>scrap_wikipedia</tt> is going to
run concurrently.
</p>
<p>
WARNING: You shouldn&#8216;t try to use <tt>register_status</tt> method
from within the block supplied to <tt>defer</tt>. Because, if you do that,
you can get corrupted result hashes. However, if you are confident, you
should wrap your status_hash ( or whatever data type, you are going to
store as a status ) in a mutex and then use <tt>register_status</tt> . It
would make sure that, only one thread resisters status at a time.
</p>
</li>
<li>Internal Server and Unhandled Exception Logging on console :

<p>
Sometimes you may want all the internal error messages and unhandled
exceptions to appear on the console. For that, you can start backgroundrb
with the following config option :
</p>
<pre>
 # backgroundrb.yml

 | :backgroundrb:
 |   :port: 11006
 |   :ip: 0.0.0.0
 |   :log: foreground
</pre>
<p>
When you are using this config option, make sure that you are starting
backgroundrb in foreground mode using :
</p>
<pre>
  ./script/backgroundrb # don't use start argument, if you have :log: foreground set
</pre>
</li>
</ul>
<h3>Testing</h3>
<ul>
<li>where will you be without test cases Phaedrus? This new version comes with
a baked in mechanism to write test cases. First make sure that you have
bdrb_test_helper.rb in the test directory of your rails app (run rake
backgroundrb:setup, if you dont have one).

<p>
Just put your worker test cases in test/unit directory of your rails
application and require the helper. Now, you should be good to go.
</p>
<pre>
 require File.join(File.dirname(__FILE__) + &quot;/../bdrb_test_helper&quot;)
 require &quot;god_worker&quot;

 context &quot;When god worker starts&quot; do
   setup do
     god_worker = GodWorker.new
   end
 end
</pre>
<p>
All above helper file does is that it stubs out, relevant worker methods,
which really need network IO. There can be methods added, which
aren&#8216;t stubbed, for all such methods you are encouraged to stub them
and send the patch to the backgroundrb mailing list.
</p>
</li>
</ul>
<h3>Legacy and deprecated stuff</h3>
<pre>
   Although You need to wrap your head a bit to understanding the &quot;evented&quot; model of network programming,
   it gets easier once you get hang of it. Much of the older stuff is deprecated. Here is a brief list:

   - ACL : gone, trust to thy firewalls.
</pre>
<h3>Exciting new stuff</h3>
<pre>
  * Rock solid stable ( or will be , after few bug reports )
  * Each worker comes with an Event loop of its own and can potentially do lots of fancy stuff. Two noteworthy methods are:

         connect(ip,port,Handler)
         start_worker(ip,port,Handler)

    If you are familiar with the EventMachine or Twisted style of network programming, the above methods allow you to
    start tcp servers inside your workers or let you connect to external tcp servers. For Each accepted client or
    connected socket, an instance of Handler class would be created and integrated with main event loop.
    This can be used for worker to worker communication between backgroundrb servers running on two machines.

    You are encouraged to look into framework directory and see the code that implements all this stuff.  The guts of
    this new version of bdrb is based on this library which will be released soon as a separate entity.
</pre>
<h2>Online Resources</h2>
<ul>
<li><a
href="http://svn.devjavu.com/backgroundrb/trunk">svn.devjavu.com/backgroundrb/trunk</a>

</li>
<li><a href="http://backgroundrb.devjavu.com">backgroundrb.devjavu.com</a>
(trac)

</li>
<li><a href="http://backgroundrb.rubyforge.org">backgroundrb.rubyforge.org</a>
(rdoc)

</li>
</ul>
</div>









</div>

  </div>

    </body>
</html>